package vsu;

/*
Абстрактный класс
■ Абстрактные классы используются как основа для
создания «реальных» классов
■ Нельзя создать экземпляр абстрактного класса
■ Абстрактный класс может не иметь абстрактных
методов
■ Абстрактный класс может иметь конструкторы

Синтаксис
public abstract class Person {
. . .
 public abstract String getSummary(){
 . . .
 }
}
public class Employee extends Person {
}

Абстрактные методы
■ Методы, не имеющие реализации
○ Заготовка для последующей реализации
○ Могут быть объявлены только в абстрактных классах
○ Должны быть реализованы в неабстрактных подклассах

Синтаксис
public abstract class Person{
. . .
    public abstract float getSalary();
}
public class Employee extends Person{
. . .
    @Override
    public float getSalary(){
    return salary+salary*0.1;
    }
}

и по идее Person - обстрактным должен быть тк что за персон, не может его существовать
так что делаем его осбактным и чтобы не могли экземпляр его создать



Модификатор static
● inner class
● field
● method
● initializer
до этого все методы, поля были экземплярными (те привязанными к экземпляру класса)
а static делает наши члены класса глобальными он их отделяет от экземпляра и распространяет на все экземпляры

Модификатор static
● static-метод не виртуальный
● static-метод может использовать только static-поля
static String text = “FirstName”;
static void aClassMethod() {
System.out.println(text);

main() method
public static void main(String[] args) {
// Method body goes here
}
}

Зачем нужен static
● точка входа в программу - метод main()
● final static константы, экземпляры вспомогательных классов
● static методы - методы не использующие состояние объекта, не
зависящие от состояния объекта
● static конструкторы
● static методы создающие экземпляры класса (паттерн фабрика)


 */
public class Main {
    public static void main(String[] args) {
        Person.printCurrentDate(); //те статик методы мы можем вызывать без создания
        // экземпляра класса

        Terminator terminator = new Terminator("kill Sarah Konnor");
        IEnergyTester energyTester = terminator;
        energyTester.validate(123);

        IResponsibilityChacker responsibilityChacker = terminator;
        responsibilityChacker.check("FSDFS");//Те открываем окно только на методы которые есть в интерфейсе

        energyTester.doSuperJob();//из экземплярной переменной можем его вызывать

    }
}
/*
Интерфейс
● Интерфейсы предназначены для реализации модульности и слабой
связанности классов
● Интерфейс - это “контракт” на предоставляемый набор
функциональности (методов)
● Интерфейс - это регламент взаимодействия между классами
● Интерфейс - это абстракция, позволяющая отделить описание от
реализации
● Наследование класса расширяет функциональность “вертикально”,
реализация интерфейса “горизонтально”

классы реализуют интерфейсы(и много можно выбрать )  (а вот предок только один может быть)

у класса 100 методово и они имплементируются от 3 разных интерфейсов и
обьявляя переменную типа какого-нибудь из этих интерфейсов мы скрываем все методы, которые класс имплементирует,
кроме методов имплимментирующих от интерфейса,которого переменную мы задали

Interface
<modifiers> interface <interface-name> {
    Constant-Declaration
    Method-Declaration
    Nested-Type-Declaration
}

отличие абстрактного класса от интерфейса:
- у абстрактного класса есть поля у интерфейса нет(любые статик, обычные, экземплярные)
у интерфейса только мб константные поля
-все методы интерфейса обстрактные, у
-у интерфейса множественное наследование у класса единичное
 */
